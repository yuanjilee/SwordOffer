# SwordOffer

《剑指 offer》学习笔记，C++实现
编译环境：c++11
测试工具：VSCode

个人经验：

1. 做算法题如果没有直接思路，多考虑辅助容器，如 map, vector, stack 等等
2. 实在没有思路可以考虑暴力法
3. 现有思路再考虑优化时间/空间复杂度
4. 遇 logn，想二分
5. 链表遇环，快慢指针

- [JZ1 二维数组中的查找](./JZ1二维数组中的查找/find_from_array.cpp)
- [JZ5 用两个栈实现队列](./JZ5用两个栈实现队列/stack.cpp)
- [JZ6 旋转数组的最小数字](./JZ6旋转数组的最小数字/min_array.cpp)
- [JZ7 斐波那契数列](./JZ7斐波那契数列/fibonacci.cpp)
- [JZ08 跳台阶](./JZ08跳台阶/jump_float.cpp)
- [JZ9 跳台阶扩展问题](./JZ9跳台阶扩展问题/jump_float_II.cpp)
- [JZ10 矩阵覆盖](./JZ10矩阵覆盖/rect_cover.cpp)
- [JZ11 二进制中 1 的个数](./JZ11二进制中1的个数/number_of_1.cpp)
- [JZ12 数值的整数次方](./JZ12数值的整数次方/power.cpp)
- [JZ13 调整数组顺序使奇数位于偶数前面](JZ13调整数组顺序使奇数位于偶数前面/reorder_array.cpp)
- [JZ14 链表中倒数第 k 个节点](./JZ14链表中倒数第k个节点/find_k_from_tial.cpp)
- [JZ15 反转链表](./JZ15反转链表/reverse_list_node.cpp)
- [JZ16 合并两个排序的列表](./JZ16合并两个排序的列表/merge_list.cpp)
- [JZ18 二叉树的镜像](./JZ18二叉树的镜像/mirror_tree_node.cpp)
- [JZ20 包含 min 函数的栈](./JZ20包含min函数的栈/min.cpp)
- [JZ21 栈的压入、弹出序列](./JZ21栈的压入、弹出序列/is_pop_order.cpp)
- [JZ28 数组中出现次数超过一半的次数](./JZ28数组中出现次数超过一半的次数/more_than_half_num.cpp)
- [JZ29 最小的 k 个数](./JZ29最小的k个数/least_numbers.cpp)
- [JZ30 连续子数组的最大和](./JZ30连续子数组的最大和/find_greatest_sum.cpp)
- [JZ34 第一个只出现一次的字符位置](./JZ34第一个只出现一次的字符位置/find_first_char.cpp)
- [JZ36 两个链表的第一个公共节点](./JZ36两个链表的第一个公共节点/find_common_node.cpp)
- [JZ37 数字在升序数组中出现的次数](./JZ37数字在升序数组中出现的次数/get_number_of_k.cpp)
- [JZ38 二叉树的深度](./JZ38二叉树的深度/tree_depth.cpp)
- [JZ39 平衡二叉树](./JZ39平衡二叉树/is_balanced_tree.cpp)
- [JZ40 数组中只出现一次的数字](./JZ40数组中只出现一次的数字/find_once_num.cpp)
- [JZ41 和为 S 的连续正数序列](./JZ41和为S的连续正数序列/find_continuous_sequence.cpp)
- [JZ42 和为 S 的两个数字](./JZ42和为S的两个数字/find_num_with_sum.cpp)

- [JZ43 左旋转字符串](./JZ43左旋转字符串/left_rotate_string.cpp)
- [JZ45 扑克牌顺子](./JZ45扑克牌顺子/is_continuous.cpp)
- [JZ48 不用加减乘除做加法](./JZ48不用加减乘除做加法/add.cpp)
- [JZ50 数组中重复的数字](./JZ50数组中重复的数字/duplicate.cpp)
- [JZ51 构建乘积数组](./JZ51构建乘积数组/multiply.cpp)
- [JZ53 表示数值的字符串](./JZ53表示数值的字符串/is_numeric.cpp)
- [JZ54 字符串中第一个不重复的字符](./JZ54字符串中第一个不重复的字符/first_unrepeat_char.cpp)
- [JZ55 链表中环的入口节点](./JZ55链表中环的入口节点/entrance_node_of_circle.cpp)
